## 1. React Hooks 기본 
: React Hooks 소개, useState, useEffect 작성 방법
### 상태 (State)
: 컴포넌트 자체적으로 값을 가지고 있는 데이터\
: 직접적으로 State를 변경하는 것은 많은 복잡성이 발생하므로 React 자체적으로 변경하는 것이 좋다.
> Props와 함께 React의 핵심 개념
>> Props는? 상위 컴포넌트에서 하위 컴포넌트에게 데이터를 전달하는 것.
### React Hooks들
: React v16.8 이전까지는 State를 가질 수 없었던 Function 컴포넌트에도 State를 가질 수 있게 해주는 개념 및 React가 지원하는 함수 중 use로 시작하는 것을 통칭하는 명칭.
### 1. useState
: 함수 return 값은 배열\
: 1번째에는 useState에 넘겨준 값, 2번째에는 값을 변경할 수 있는 함수가 있음.\
``` jsx
import React, { useState } from 'react'

const Counter = () => {
  const [nickname, setNickname] = useState('Danuel')
  const [count, setCount] = useState(0)

  const decreaseCount = () => setCount(count - 1)
  // 유의미한 이름을 가진 변수로 작성해 사용하는 것 추천!

  return (
    <div>
      <p>{nickname}</p>
      <p>{count}</p>
      <button onClick={decreaseCount}>- 1</button>
      <button onClick={() => setCount(count + 1)}>+ 1</button>
    </div>
  )
}
```
: 컴포넌트 안에는 useState를 여러 번 사용 가능하며, 여러 State를 가질 수 있다는 것을 의미함.\
### 2. useEffect
: 해당 컴포넌트의 연산이 끝난 이후 함수를 실행한다.\
=> 화면에 그리는 작업이 끝난 후에 발동한다고 할 수 있음.
import React, { useEffect, useState } from 'react'
``` jsx
const Counter = () => {
  const [nickname, setNickname] = useState('Danuel')
  const [count, setCount] = useState(0)

  const decreaseCount = () => {
    setCount(count - 1)
  }
  const increaseCount = () => {
    setCount(count + 1)
  }

  useEffect(() => {
    document.title = count
  })

  return (
    <div>
      <p>{nickname}</p>
      <p>{count}</p>
      <button onClick={decreaseCount}>- 1</button>
      <button onClick={increaseCount}>+ 1</button>
    </div>
  )
}
```
> useEffect 사용하지 않으면 일부만 다른 중복 코드와 확장성 부분에서 만족스럽지 않다.
### 👩‍🏫Hooks의 사용 규칙
#### 1. 선택적 실행 금지 (only call hooks at the top level)
: Hooks는 실행 순서와 깊은 연관이 있기 때문에 상태에 의하거나 조건에 따라 실행하게 되면 정상적인 작동을 하지 않는다.
``` jsx
import React, { useEffect, useState } from 'react'

const User = () => {
  const [nickname, setNickname] = useState('Danuel')

  if (nickname === 'Unknown') {
    useEffect(() => {
      // ...
    })
  }

  return <h1>{nickname}</h1>
}
```
#### 2. Function 컴포넌트에서만 사용 가능
: class 컴포넌트는 hooks와는 별개로 가지고 있는 상태 관리 방법이 있기 때문에 복잡성 등의 이유로 사용할 수 X.

### 🍯꿀팁
#### 1. useState 유연하게 사용하기
: 초기화 할 때만 함수를 1번 실행하는 방식을 지원하므로, 처음 1번만 함수를 실행하고 그 함수의 return 값을 state로 사용하자.
``` jsx
import React, { useState } from 'react'

const ExpensiveComponent = () => {
  const [someValue, setSomeValue] = useState(() => {
    let value = 0
    for (let index = 0; index < 100_0000; index += 1) {
      value += 1
    }
    return value
  })

  return <div>{someValue}</div>
}
```
#### 2. useEffect 유연하게 사용하기
: 이전의 state와 현재의 state가 다를 때만 useEffect 함수가 발동하는 것이 가장 효율적이다.
``` jsx
...
useEffect(() => {
  document.title = nickname
}, [nickname])
...
```
#### 3. 비동기적인 State 변경하기
``` jsx
import React, { useState } from 'react'

const SECOND = 1000

const AsynchronousCounter = () => {
  const [nickname, setNickname] = useState('Danuel')
  const [count, setCount] = useState(0)

  const decreaseCount = () => {
    window.setTimeout(() => setCount(count - 1), 3 * SECOND)
  }
  const increaseCount = () => {
    window.setTimeout(() => setCount(count + 1), 3 * SECOND)
  }

  return (
    <div>
      <p>{nickname}</p>
      <p>{count}</p>
      <button onClick={decreaseCount}>- 1</button>
      <button onClick={increaseCount}>+ 1</button>
    </div>
  )
}
```
> 버튼을 클릭하면 3초 후에 state를 바꾸는 컴포넌트다.
>> 하지만, 연속적으로 클릭해보면 예상과는 다른 작동을 한다.

: 버튼을 클릭하면 3초 후에 state를 변경하는 함수를 실행하는데, 이 순간에 들어가는 값은 버튼을 클릭한 시점의 state로 이미 결정해놓았기 때문이다.

#### 해결방법
: React에서는 State를 변경하는 함수의 파라미터에 함수를 넘기는 방법을 지원하기 때문에 setCount 함수에 함수를 넘겨주면 된다.
``` jsx
import React, { useState } from 'react'

const SECOND = 1000

const AsynchronousCounter = () => {
  // ...

  const decreaseCount = () => {
    window.setTimeout(() => setCount(previousCount => previousCount - 1), 3 * SECOND)
  }
  const increaseCount = () => {
    window.setTimeout(() => setCount(previousCount => previousCount + 1), 3 * SECOND)
  }

  // ...
}
```
> 함수로 넘겨줄 때에는 '직전'의 State를 입력으로 받고 다음 State를 return 한다.

## 2. Custom Hooks 알아보기
: React Hooks를 조금 더 유연하게 사용할 수 있는 방법
### Custom Hooks의 기본 형태
: 별도의 함수로 분리해서 작성하는 것이다.
``` jsx
import React, { useState } from 'react'

const User = () => {
  const [nickname, setNickname] = useState('')

  const updateNickname = event => {
    const nickname = event.target.value

    setNickname(nickname)
  }

  return (
    <div>
      <label>{nickname}</label>
      <input value={nickname} onChange={updateNickname} />
    </div>
  )
}

// custom hooks의 기본 형태로 바꾸면
import React, { useState } from 'react'

const useUser = () => {
  const [nickname, setNickname] = useState('')
  const [isAdmin, setBeAdmin] = useState(false)

  const updateNickname = event => {
    const nickname = event.target.value

    setNickname(nickname)
  }

  return [nickname, updateNickname]
}

const User = () => {
  const [nickname, setNickname] = useUser()

  return (
    <div>
      <label>{nickname}</label>
      <input value={nickname} onChange={setNickname} />
    </div>
  )
}
```
### Custom Hooks 장점
- 컴포넌트와 로직을 분리할 수 있음.
- 컴포넌트와 로직을 조합하는 형태로 작성이 가능함.
- 여러 컴포넌트에서 재활용이 가능해 중복 코드를 줄일 수 있음.
- 여러 React 프로젝트를 진행한다면 효용성 좋은 Custom Hooks를 공유해 기술적 경험을 축적할 수 있음.

## 3. useRef 알아보기
: Ref와 React Hooks의 기본 API 중 하나.
### document.getElementById
: 해당 프로젝트 안에서 유일한 id를 지정하면 document.getElementById 메서드로 직접 Element를 불러와서 사용할 수 있음.
``` jsx
...
const User = () => {
  ...
  const idReference = document.getElementById('id')
  const passwordReferenece = document.getElementById('password')

  const id = idReference.target.value
  const password = passwordReferenece.target.value
}
...
```    
### Ref
: 