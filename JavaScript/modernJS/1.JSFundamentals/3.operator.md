## 연산자
#### 🍯꿀팁) 용어정리
1. 피연산자(operand)\
: 인수라고 불리기도 하며, 연산자가 연산을 수행하는 대상이다.
> 5 * 2 일 경우, 왼쪽 피연산자 5, 오른쪽 피연산자 2이다.
2. 단항 연산자\
: 피연산자를 하나만 받는 연산자
> -x 같은 친구들.
3. 이항 연산자\
: 피연산자를 두개 받는 연산자
> y-x 같은 친구들.

### +를 이용한 문자열 연결
: 이항 연산자 +의 피연산자로 문자열이 전달되면, 덧셈이 아닌 문자열 병합(연결)이 일어난다.
> 피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환된다.

### +를 이용한 숫자형 변환
: 피연산가자 숫자가 아닌 경우에 +를 붙이면 숫자형으로 변환이 일어난다.\
=> Number(...)와 같은 역할이 가능하다.

### 연산자 우선순위
> 곱셈은 덧셈보다 더 높은 우선순위를 가지는 것과 같다.

: 동일한 기호의 단항 연산자는 이항 연산자보다 우선순위가 더 높다.

### 할당 연산자
: 무언가를 할당할 때 쓰이는 =도 연산자다.\
: 우선순위가 3으로 아주 낮다.\
: 여러 개를 연결할 수 있음(체이닝)
: 값을 반환한다.
``` js
a = b = c = 2 + 2;
```

### 연산자 모음집
#### 나머지 연산자 %
: a%b는 a를 b로 나눈 후 그 나머지를 정수로 반환해준다.
#### 거듭제곱 연산자 **
: 자연수 b가 있을 때, a ** b는 a를 b번 곱한 값이 된다.\
: 거듭제곱 연산자는 정수가 아닌 숫자에 대해서도 동작한다.
> 1/2 제곱근, 1/3 세제곱근
#### 증가/감소 연산자
1. 증가 연산자 ++\
: 변수를 1 증가시킨다.
2. 감소 연산자 --\
: 변수를 1 감소시킨다.
- ++, -- 연산자는 변수 앞이나 뒤에 올 수 있다.\
: counter++ 후위형.\
=> counter를 증가시키긴 하지만, 증가 전의 기존값을 반환한다.
: ++counter 전위형.\
=> counter를 증가시키고 새로운 값을 반환한다.

### 비트 연산자(bitwise operator)
: 인수를 32비트 정수로 변환해 이진 연산을 수행한다.
- 비트 AND(&)
- 비트 OR(|)
- 비트 XOR(^)
- 비트 NOT(~)
- 왼쪽 시프트(<<)
- 오른쪽 시프트(>>)
- 부호 없는 오른쪽 시프트(>>>)

### 복합 할당 연산자
: 프로그램을 짜다 보면, 변수에 연산자를 적용하고 그 결과를 같은 변수에 저장해야 하는 경우가 종종 생긴다.\
=> 이때, 복합 할당 연산자를 사용하면 짧은 문법으로 동일한 연산 수행 가능.\
: 산술 연산자와 비트 연산자에도 적용할 수 있다.\
: ```+=, *=, /=, -=```

### 쉼표 연산자
: 여러 표현식을 코드 한 줄에서 평가할 수 있게 해준다.\
: ,는 좀처럼 보기 힘들고, 특이한 연산자 중 하나.
> 코드를 짧게 쓰려는 의도로 가끔 사용된다.
>> 표현식 각각이 모두 평가되지만, 마지막 표현식의 평가 결과만 반환된다.
``` js
let a = (1+2, 3+4);
alert(a);
```
: 1+2는 평가되지만, 그 결과는 벼려지고 3+4만 평가되어 a에 할당된다.
``` js
for (a = 1, b = 3, c = a*b; a<10; a++){
    // ...
}
```
> 이런식으로 사용가능.

## 비교 연산자
- 보다 큼/작음 : a > b, a < b
- 보다 크거나/작거나 같음 : a >= b, a <= b
- 같음(동등) : a == b
- 같지 않음(부등) : a!=b
### 불린형 반환
: 비교 연산자는 값을 반환하는데, 반환 값은 boolean형이다.
- true/false
### 문자열 비교
: 사전 순으로 문자열을 비교한다.\
=> 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단.
> 사전편집(lexicographical)순\
>> 정확히는 사전순이 아니라 유니코드 순.
#### 문자열 비교 시 적용되는 알고리즘
1. 두 문자열의 첫 글자를 비교한다.
2. 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(작으면), 첫 번째 문자열이 두 번째 문자열보다 크다고(작다고) 결론 내고 비교를 종료한다.
3. 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교한다.
4. 글자 간 비교가 끝날 때까지 이 과정을 반복한다.
5. 비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론 낸다. 비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 낸다.
``` js
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```
## 다른 형을 가진 값 간의 비교
: 비교하려는 값의 자료형이 다르면 이 값들을 숫자형으로 바꾼다.
> boolean형의 경우, true = 1, false = 0으로 변환 후 비교가 이루어짐.

### 동등 연산자(equality operator)
: ```==```은 0과 false를 구별하지 못한다.
> 빈 문자열일 때도 같은 문제 발생.
``` js
alert('' == false); //true
```
#### 왜?
: 동등 연산자 ==가 형이 다른 피연산자를 비교할 때 피연산자를 숫자형으로 바꾸기 때문에 발생한다.

### 일치 연산자(strict equaliity operator)
: ```===```를 사용하면 형 변환 없이 값을 비교할 수 있다.\
=> 0과 false 구별 가능.\
: 일치 연산자는 엄격한 동등 연산자이기 때문에, 자료형의 동등 여부까지 검사한다.
> 불일치 연산자는 ```!==```

### null이나 undefined와 비교하기
#### 1. 일치 연산자 ```===```를 사용해 null과 undefined 비교
: 두 값의 자료형이 다르기 때문에 일치 비교시 false가 반환된다.
#### 2. 동등 연산자 ```==```를 사용해 null과 undefined 비교
: 동등 연산자를 사용해 null과 undefined를 비교하면 특별한 규칙이 적용되어 true가 반환된다.\
=> null과 undefined를 각별한 커플💑처럼 취급^^
#### 3. 산술 연산자나 기타 비교 연산자 ```< > <= >=```를 사용해 null과 undefined 비교
: null과 undefined는 숫자형으로 변환된다.\
=> null은 0, undefined는 NaN으로!
__👩‍🏫 세 가지 규칙 때문에 에지 케이스(edge case)가 만들어져 함정에 빠질 수 있다 ㅠㅡㅠ__

#### null vs 0
: null과 0을 비교해보자!
``` js
alert(null > 0); // false
alert(null == 0); // false
alert(null >= 0); // true
```
: 세번째가 true이면 위에 둘 중 하나는 true여야 하는데, 둘 다 거짓을 반환한다.
=> 동등 연산자(==)와 기타 비교 연산자의 동작 방식이 다르기 때문이다!

#### undefined 비교 불가능
: 다른 값과 비교해서는 안된다.
``` js
alert(null > 0); // false
alert(null < 0); // false
alert(null == 0); // false
```
> (1),(2)에서는 undefined가 NaN으로 변환되는데, NaN이 피연산자인 경우 비교 연산자는 항상 false를 반환한다.
>> undefined는 null나 undefined와 같고, 그 이외의 값과는 같지 않기 때문에 (3)은 false를 반환.

### 🍯 꿀팁
: 일치 연산자(===)를 제외한 비교 연산자의 피연산자에 undefined나 null이 오지 않도록 특별히 주의하기!\
: undefined나 null이 될 가능성이 있는 변수가(>= > < <=)의 피연산자가 되지 않도록 주의하기!